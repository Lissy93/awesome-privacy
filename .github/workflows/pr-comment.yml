name: PR Comment

on:
  workflow_run:
    workflows: ["PR Check"]
    types: [completed]

permissions:
  actions: read
  pull-requests: write

jobs:
  comment:
    name: Post PR comment
    runs-on: ubuntu-latest
    if: github.event.workflow_run.event == 'pull_request'

    steps:
      - name: Download PR metadata
        id: download
        continue-on-error: true
        uses: actions/download-artifact@v4
        with:
          name: pr-meta
          path: pr-meta
          run-id: ${{ github.event.workflow_run.id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Post or update comment
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.BOT_TOKEN || secrets.GITHUB_TOKEN }}
          script: |
            const fs = require('fs');
            const marker = '<!-- pr-check-bot -->';

            // Determine the PR number
            let prNumber;
            const numberFile = 'pr-meta/number.txt';
            if (fs.existsSync(numberFile)) {
              prNumber = parseInt(fs.readFileSync(numberFile, 'utf8').trim());
            } else {
              // workflow_run.pull_requests is empty for fork PRs, so
              // fall back to searching by head SHA if needed
              const prs = context.payload.workflow_run.pull_requests;
              if (prs && prs.length > 0) {
                prNumber = prs[0].number;
              } else {
                const headSha = context.payload.workflow_run.head_sha;
                const { data: prList } = await github.rest.pulls.list({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  state: 'open',
                  sort: 'updated',
                  direction: 'desc',
                  per_page: 10,
                });
                const match = prList.find(pr => pr.head.sha === headSha);
                if (!match) {
                  console.log(`No open PR found for SHA ${headSha} — skipping comment.`);
                  return;
                }
                prNumber = match.number;
              }
            }

            // Find existing bot comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
            });
            const existing = comments.find(c => c.body.includes(marker));

            const commentFile = 'pr-meta/comment.md';
            if (fs.existsSync(commentFile)) {
              const body = fs.readFileSync(commentFile, 'utf8').trim();
              if (existing) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existing.id,
                  body,
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body,
                });
              }
            } else if (existing) {
              // No findings — remove stale comment
              await github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
              });
            }
